input       kernel      performance                                     memory
                        mapping     order       simulate    total
11x11       1x11x11     0.6848      0.0237      3.4404      4.1500      265MB
12x12       1x11x11     0.6835      0.5317      12.630      13.846      279MB            
13x13       1x11x11     0.6866      0.8636      28.609      30.160      304MB

input增加, 時間mapping增加一點點,  order增加比較明顯, simulate增加明顯,  memroy增加

11x11       10x11x11    0.7722      1.1589      31.850      33.781      311MB
11x11       100x11x11   1.5837      5.4667      142.95      149.95      753MB

12x12       10x11x11    0.7258      2.8235      127.43      130.98      452MB

12x12       100x11x11   



* window變四倍,  mapping時間差不多, order時間增加, simulate時間就變成4倍, memroy增加不到一倍
* weight matrix變成10倍, mapping時間增加兩倍, order時間增加五倍,simulate時間就變成5倍, memroy增加兩倍多, 時間主要simulate卡住


window 1, matrix 1萬 simulate time = 150, memory = 0.30G
window 4, matrix 1萬 simulate time = 600, memory = 0.45G


caffenet
input 224 224 3             window #
conv1 96x11x11  11616       55x55       time = 150*55*55 = 453750            memory = 55*55/4 * 1.5 * 0.3 = 340G
pool  27x27
conv2 256x5x5   6400        27x27       time = 150*27*27*0.64  = 69984       memory = 27*27/4 * 1.5 * 0.3 = 82G
pool  13x13
conv3 384x3x3   3456        13x13       time = 150*13*13*0.345 = 8745        memory = 13*13/4 * 1.5 * 0.3 = 19G
conv4 384x3x3   3456        13x13       time = 150*13*13*0.345 = 8745        memory = 13*13/4 * 1.5 * 0.3 = 19G
conv5 256x3x3   2304        13x13       time = 150*13*13*0.23  = 5830        memory = 13*13/4 * 1.5 * 0.3 = 19G
fully 4096      692224      1           time = 150*69.2224     = 10383       memory = 0.3 * 69/10 * 2 = 4G
fully 4096      16777216    1           time = 150*1677.7216   = 251658      memory = 0.3 * 1677/10 * 2 = 100G
fully 10                    1

Total time   = 809095s (224Hr)
Total memory = 583 GB

list 3831M
numpy 790M


加速
input   kernel      performance(mapping/order/simulate)     memory
11x11   1x11x11     0.2027/0.0749/3.00                      83/88.6MB

1. 將crossbar array中0改成空的obj
    performance(mapping/order/simulate) 0.136/0.0268/3 
    memory  72/77.5
                             
2. 再轉乘np array
    performance(mapping/order/simulate) 5/0.03/2.9
    memory  85.3/88.5

3. 將crossbar obj直接改用list
    performance(mapping/order/simulate) 0.208/0.07/3.07
    memory  83/88.6
4. 將crossbar obj改成list後, 裡面的bit只記錄start bit, 再轉乘np array
    performance(mapping/order/simulate) 3.9/0.05/2.9
    memory  250/250.5

                    
mapping後67MB
mapping後會生成大量記憶體, controller最慢


Run
mapping時  473.5MB
order後     941MB


otimize1
    目標： 優化order memory用量
    發現: computation order這個list超大, 發現ou內的ou output佔超大改成空的[]
    優化前: 
        mapping 4.375s/  242MB
        order   22.20s/  2.17GB - 242MB
    優化後:
        mapping 4.3s / 242MB
        order   12s / 400MB - 242MB = 160MB

optimize2
    目標: 優化記憶體用量, 記憶體用量大可能會swap in out, 造成效能變低, 瘦身order來減低memory
    觀察: 優化前的memory用量, controller效能
    Model: input: 15x15x1, kernel: 10x11x11x1, bit: 16/16
    優化前:
        neclab6
            Memory: VIRT 2367M, RES 671M, MEM 0.4%
            Performance: mapping 4.5s, Order 20.2s, simulate 1077s
        mac
            Memory: 524.8MB
            Performance: mapping 4.15s, Order: 20.78s
    優化:
        本次優化減少cu_saa event紀錄的input內容, 其實後面只需要知道一個cu_saa event需要做幾次即可, 所以改幾次數。
        減少要記錄的內容可以減少記憶體使用, 再來controller判斷也做了部分優化, 且判斷也會變快！

    優化後:
       mac
            Memory: 319.9MB
            Performance: mapping 4.08, Order: 18.71s
        neclab6
            Memory: VIRT 2203MB , RES 506M, MEM 0.3%
            Performance: mapping 4.3s, Order 16.80s, simulate 1088s (無效)

optimize3
    目標: 減少mapping的memory, 不要先用list再轉乘numpy
    目前只改defatult mapping
    優化後:
        Memory: 167.8MB
        Performance: mapping: 0.097, Order: 17.5
    優化後:(caffenet)
        Memory: 10G
        Performance: mapping: 1107s, Order: 用上面數字算的話需要175倍(53hr)

optimize4
    目標: 優化controller速度, 使用連凱提供方法
    Model: input: 13x13x1, kernel: 10x11x11x1, bit: 16/16
    優化前:
        mac
            Performance: mapping 0.098s, Order: 6.046s, simulate: 364.3s
    1. 改ou erp
    優化後:
        mac:
            Performance: mapping 0.101s, Order: 6.186s, simulate: 358.06s
    2. 改adc erp
    優化後:
        mac:
            Performance: simulate: 355.47s
    3. cu_saa一次全部做完不要每次做一個remove一個, 做完直接清空
    優化後:
        mac:
            Performance: simulate: 352.169s
    4. pe_saa
    優化後:
        mac:
            Performance: simulate: 353.39s
    5. 改act 用dequeue
    優化後:
        mac:
            Performance: simulate: 361.0s
    6. 改write 用dequeue
    優化後:
        mac:
            Performance: simulate: 361.0s
    測試：
        Model: input: 15x15x1, kernel: 10x11x11x1, bit: 16/16
        optimize2的數據
        neclab6
        優化前:
            Performance: simulate 1088s
        優化後:
            Performance: 1014.94s


Lenet
    Mapping: 2922M, 187M, 14.943s
    Order:  9149M, 6409M, 734.04s
    [926, 4616896, 4616896, 4616896, 10718, 10718, 11894, 1176, 33804] 13,941,045
    simulate: 93741s (5800event/39s) 26hr

Alexnet會產生的event約為lenet的722倍


optimize5
    目標: 瘦身computation order
    方法: 16bits不要只生一份就好
    Lenet
        Order: 6409M, 734.04s -> 824M, 50s
        [926, 288556, 288556, 288556, 10718, 10718, 11894, 1176, 33804] 936,080
        simulate: 93741s (5800event/39s) 26hr

    8000 Done event: 20310 time per event 0.09663141283244701 time per cycle 0.24532299956679343
    edram: 2.6799349784851074 ou 44.533835887908936 adc 1.8012521266937256 cusaa 1.7140617370605469 pesaa 0.06391620635986328 act 0.01003122329711914 wr 0.014477252960205078
    iterconeect 32.52555322647095 fetch 0.005879402160644531 trigger 67.94741702079773 state 222.9602987766266 other 115.51902675628662
    t: 489.85399699211

